# `ga.py` — Núcleo del algoritmo genético para TSP (flujo completo, parámetros y funciones)

Este archivo implementa el **motor evolutivo** que toma una instancia TSPLIB (`.tsp`), construye su matriz de distancias comprimida, crea una población inicial y ejecuta un **ciclo generacional** con selección, cruce, mutación y **mejoras locales paralelas**, además de mecanismos de diversidad (histograma de aristas, emparejamiento assortative, especies) y recuperación (catástrofes). Registra trazas en CSV, perfil de tiempos y devuelve el mejor tour y métricas del run.

## Entrada y preparación (antes del bucle evolutivo)

1. **Lectura y distancias**

   - `parseTsp(...)` obtiene nombre, tipo de métrica y coordenadas.
   - `buildDistanceMatrixCompressed(...)` calcula el **triángulo superior** en un vector $O(n^2/2)$ con redondeos TSPLIB exactos; se conserva para consultas O(1) vía `getDistance(...)`.
   - El costo de tours se evalúa con `tourDistance(...)` y se memoiza en un **fitness cache** para evitar recálculos.

2. **Población inicial**

   - `initPopulation(...)` arma una mezcla de **semillas heurísticas** y **aleatorios**, luego se **ordena** por fitness (estable por `(coste, tuple(tour))`) para garantizar reproducibilidad con la misma semilla RNG.

3. **k-NN para acelerar 2-opt/3-opt**

   - `buildKnn(...)` (función anidada en `runGa`) obtiene, para cada ciudad, sus **k vecinos más cercanos** sin ordenar todo el conjunto (`heapq.nsmallest`) y así filtra intercambios poco prometedores.

4. **Pool paralelo para 2-opt**

   - `ProcessPoolExecutor` crea procesos trabajadores que comparten parámetros globales con `initTwoOptGlobals(...)`.
   - Cada candidato en el **pool 2-opt** se mejora en un worker con `twoOptWorker(...)` (hasta 12 pasos **first-improve**), evitando bloquear el bucle principal.

5. **Trazas y perfil**

   - `openTrace(...)` abre un CSV y escribe un encabezado; cada evento usa `writeTrace(...)`.
   - Se inicializa un diccionario `prof` para **perfilar** el tiempo por etapa (selección, cruce, 2-opt, especies, etc.).

## Operadores y utilidades (bloques funcionales)

- **Selección** — `selectionTournament(pop, fitness, k, num)`
  Elige `num` padres con **torneo** de tamaño `k`, resolviendo empates de forma estable por tupla del tour.

- **Cruces**

  - `crossoverOX(p1, p2)` — **Order Crossover** clásico.
  - `crossoverSCX(p1, p2, n, vec, edgeFreq, edgeLambda)` — **SCX** sesgado por el **histograma de aristas**: penaliza distancia base y **bonifica** aristas frecuentes (parámetro `edgeLambda`), con desempate por índice para estabilidad.
  - `eaxLite(p1, p2, n, vec, neighbors)` — mezcla adyacencias de ambos padres (next/prev); si no hay candidatos, recurre a KNN y, en último caso, a los **no usados**; siempre elige por `(distancia, idx)` para estabilizar. Este operador se aplica a una fracción `eaxFrac` del presupuesto de cruces.

- **Mutaciones**

  - `mutateInsertion(t)` — extrae un gen en `j` e inserta en `i` (barata y eficaz).
  - `mutateSwap(t)` — intercambio simple de dos posiciones.
    Se usan en dos modalidades: **pura** (para llenar la fracción de mutación) y **ligera** (pos-metamórfica con probabilidad `pm`).

- **Mejoras locales**

  - `apply2optOnce(t, n, vec, neighbors, first_improve, useFlocking)` — un paso 2-opt que, si hay KNN, filtra pares; "**flocking**" rompe empates priorizando la **menor arista nueva máxima**; puede operar en modo **first-improve** (paralelo) o **best-improve** (determinista).
  - `apply3optOnce(t, n, vec, neighbors)` — dos variantes simples de 3-opt en modo **first-improve** con KNN; se usa de forma **acotada** y esporádica en élites para no sobrecargar.
  - `twoOptWorker(t)` — aplica hasta 12 pasos **first-improve** en un proceso del pool y devuelve el tour mejorado.

- **Diversidad y emparejamiento**

  - `edgeKey(u,v)`, `buildEdgeSet(tour)` — representación **no dirigida** de aristas (clave ordenada) y conjunto del tour.
  - `jaccardEdgeDistance(Ea, Eb)` — distancia Jaccard sobre aristas ($1 - \frac{|\cap|}{|\cup|}$).
  - `buildEdgeHistogram(pop, topFrac)` — **frecuencias normalizadas** de aristas en el **top** de la población (para sesgar SCX).
  - `assortativePairs(parents, numPairs, edgeSets)` — empareja maximizando distancia Jaccard (más **lejanos**), con orden estable.

- **Perturbación / reinicio parcial**

  - `doubleBridgeKick(t)` — 4-cortes tipo Lin-Kernighan para **escapar** de óptimos locales, seguido de 2-opt corto; se usa en **catástrofes** y **kicks** periódicos.

- **Trazas y utilidades**

  - `openTrace(path, header)` abre un CSV (o no, si `None`) y escribe cabecera.
  - `writeTrace(writer, row)` añade una fila si hay escritor válido.

## Bucle evolutivo

El ciclo principal vive en `runGa(...)` y avanza **generación a generación** hasta que se cumple **límite de iteraciones**, **tiempo** o **estancamiento**. Cada vuelta realiza:

1. **Congelar parámetros** de la CLI (`pm`, `twoOptProb`, `k`) para evitar derivas accidentales.

2. **Sobrevivientes + "memético suave" periódico**

   - Se copian los `S` mejores.
   - Cada 300 generaciones, se aplica a una pequeña porción: varios pasos 2-opt **first-improve** y **hasta `mem3OptSteps` de 3-opt** (acotado), cuidando tiempo.

3. **Selección** por torneo para cubrir el **presupuesto de cruces** (padres).

4. **Emparejamiento**

   - Si `assortative=True`, se forman parejas con **máxima lejanía de aristas** (Jaccard), usando `assortativePairs(...)`.
   - Si no, emparejamiento secuencial simple.

5. **Cruce**

   - Con prob. `pc`, cada pareja produce un hijo por **EAX-lite** (presupuesto `eaxFrac`) o por **SCX/OX**; si no se cruza, se copia uno de los padres. Se contabiliza tiempo por "crossover" y por "crossover_eax".

6. **Mutación**

   - **Pura**: genera `M` individuos a partir de tours base con `mutateInsertion` o `mutateSwap`.
   - **Ligera**: con prob. `pm` aplicada a los hijos de cruce.

7. **2-opt paralelo (pool)**

   - Se calcula un `poolSize = twoOptProb * (#childrenC + #childrenM)` con los **mejores** según fitness y se manda a `twoOptWorker` en paralelo; luego se **reemplaza establemente** la versión mejorada.

8. **Recomposición + élites + anticlones**

   - `newPop = survivors + childrenC + childrenM`, imponiendo **élites** (copiados intactos).
   - **Anticlones**: tours repetidos sufren `swap+insertion` y, si persisten, se **reemplazan** por aleatorios; garantiza **diversidad efectiva**.
   - Se ajusta el tamaño a `N` (recorte o relleno).
   - Se **ordena** por fitness con clave estable.

9. **Actualización del histograma de aristas**

   - Cada `edgeFreqPeriod` generaciones, `buildEdgeHistogram(...)` recalcula frecuencias del **top** `edgeTopFrac`; SCX las usa para sesgo pro-aristas prometedoras (`edgeLambda`).

10. **Especies (clustering por aristas)**

    - Cada `speciesPeriod`, `rebuildSpecies()` agrupa población por **Jaccard <= speciesThresh**.
    - Si hay estancamiento, se puede **extinguir parcialmente** la peor especie (`speciesCullFrac`) reemplazando sus miembros por tours nuevos (con breve 2-opt).

11. **Actualización de mejor / eventos**

    - Si hay **nuevo best**, se actualiza `history`, se **registra** evento "improve" con tiempo y delta, y opcionalmente se **guarda un frame** con `saveFrame(...)`.
    - Si no mejora, se **incrementa** `noImprove`. En hitos de estancamiento:

      - **Catástrofe** (cada \~`stallGenerations/2`): reemplaza la cola por **double-bridge + 2-opt corto** y reinicia `noImprove`.
      - **Kick periódico** (cada 3000 sin mejora): hace un **double-bridge global** sobre el best y lo **optimiza** con 2-opt "best-improve"; si mejora, se adopta.

12. **Paradas**

    - Por **tiempo** (`timeLimitSec`), por **stall** (`stallGenerations`) o por **maxIter**. Se registra un evento "stop".

## Cierre y salidas

- **Perfil de tiempos**: se imprime el desglose (parseo, KNN, init, cada bloque del bucle).
- **Pulido final**: 2-opt **best-improve** global sobre el best para quitar residuos locales y fijar el `bestCost` definitivo.
- **CSV**: fila "end" con resumen (mejor costo, generaciones, tiempos, parámetros clave y dimensión LP teórica). El archivo se cierra con seguridad.
- **Retorno (`dict`)**:
  `{"name", "coords", "bestTour", "bestCost", "history", "events", "framesDir", "stoppedBy", "elapsedSec", "gensDone", "genPerSec"}` — suficiente para informes/visualización externa.

## Parámetros principales de `runGa(...)` (qué controlan)

- **Tamaño/tiempo/parada**: `N`, `maxIter`, `stallGenerations`, `timeLimitSec`.
- **Mezcla evolutiva**: `survivorsFrac`, `crossoverFrac`, `mutationFrac` (suman 1.0).
- **Operadores**: `pc` (prob. cruce), `pm` (prob. mutación por individuo: `None` -> max(1/n,0.002), `-1` -> 1/n), `useSCX` (si `False`=OX), `twoOptProb` (fracción de hijos mejorados en pool).
- **Élite y selección**: `elitismFrac`, `tournamentK`.
- **Diversidad**:

  - **Edge-histogram**: `eaxFrac` (presupuesto EAX), `edgeLambda` (peso de la frecuencia), `edgeTopFrac` (porción top), `edgeFreqPeriod` (periodicidad de actualización).
  - **Emparejamiento**: `assortative` (ON por defecto, parejas "lejanamente" distintas).
  - **Especies**: `speciesPeriod`, `speciesThresh`, `speciesCullFrac`.
  - **Catástrofes**: `catastropheFrac` (reemplazo de la cola).
- **Memética y tie-break**: `mem3OptSteps` (3-opt acotado en élites), `useFlocking` (desempate en 2-opt favoreciendo aristas más cortas).
- **Registro**: `recordImprovements`, `framesDir`, `trace_csv`, `seed`.
